Data Race l√† g√¨?
Th·ª±c ch·∫•t l√† m√¨nh kh√¥ng nghƒ© ra ‚Äúl√† c√≥ kh√°i ni·ªám Data race‚Äú, v√¨ trong khi ƒë√£ c√≥ kh√°i ni·ªám Race Condition r·ªìi. V√† trong qu√° tr√¨nh ƒë·ªçc th√™m c√°c s√°ch, b√°o, t√†i li·ªáu ‚Ä¶ n√≥ l·∫°i ƒë∆∞·ª£c ƒë·ªÅ c·∫≠p t·ªõi v√†i l·∫ßn. Sau khi v√†i ƒë∆∞·ªùng Google th√¨ c·∫£ m·ªôt ch√¢n tr·ªùi ki·∫øn th·ª©c hi·ªán ra. Tuy nhi√™n, 2 kh√°i ni·ªám kh√° l√† r·∫Øc r·ªëi v√† d√¢y m∆° r·ªÖ m√° v·ªõi nhau r·∫•t nhi·ªÅu.

M√¨nh s·∫Ω s·ª≠ d·ª•ng v√† tr√≠ch d·∫´n kh√° nhi·ªÅu trong b√†i vi·∫øt n√†y. Hi v·ªçng b·∫°n s·∫Ω hi·ªÉu ƒë∆∞·ª£c, c√≤n kh√¥ng hi·ªÉu th√¨ kh√¥ng sao. Ch·ªâ c·∫ßn th√¥ng ƒë∆∞·ª£c 2 ph·∫ßn cu·ªëi c·ªßa b√†i vi·∫øt l√† ·ªïn r·ªìi.

Kh√°i ni·ªám
Data Race x·∫£y ra khi c√≥ t·ª´ 2 thread tr·ªü l√™n c√πng truy c·∫≠p v√†o m·ªôt v√πng nh·ªõ chung (shared resource) v·ªõi √≠t nh·∫•t 1 thread th·ª±c hi·ªán vi·ªác thay ƒë·ªïi gi√° tr·ªã tr√™n v√πng nh·ªõ ƒë√≥.

ƒê·ªçc qua th√¨ n√≥ c≈©ng gi·ªëng kh√°i ni·ªám Race Condition. Ch√∫ng ta s·∫Ω ph√¢n t√≠ch 2 m·ªëi quan h·ªá ƒë√≥ ·ªü ph·∫ßn sau.

ƒêi·ªÅu ki·ªán ƒë·ªÉ Data Race x·∫£y ra nh∆∞ sau:

C√≥ t·ª´ 2 thread tr·ªü l√™n c√πng truy c·∫≠p v√†o shared resource (d·ªØ li·ªáu d√πng chung) ƒë·ªÉ ƒë·ªçc ho·∫∑c ghi. C·ª• th·ªÉ shared resource l√† 1 variable ho·∫∑c 1 object.
C√≥ √≠t nh·∫•t 1 thread thay ƒë·ªïi gi√° tr·ªã c·ªßa variable ho·∫∑c object ƒë√≥. N·∫øu t·∫•t c·∫£ thread ch·ªâ ƒë·ªçc d·ªØ li·ªáu s·∫Ω kh√¥ng x·∫£y ra data race.
V√≠ d·ª•
Trong th·ª±c t·∫ø, v√≠ d·ª• c·ªßa data race l√† b√†i to√°n kinh ƒëi·ªÉn r√∫t ti·ªÅn t·∫°i c√¢y ATM. Gi·∫£ s·ª≠ c√≥ 1 th·∫ª ATM v√† 1 th·∫ª Visa Debit c√πng link ƒë·∫øn 1 t√†i kho·∫£n ng√¢n h√†ng v√† ƒëi r√∫t ti·ªÅn c√πng l√∫c. Trong t√†i kho·∫£n c√≤n 50k v·ª´a ƒë·ªß l√†m b√°t b√∫n real cool v√† c·ªëc tr√† ƒë√°. M√¨nh ƒë·ªìng th·ªùi r√∫t ·ªü c·∫£ 2 m√°y ATM 50k. N·∫øu kh√¥ng x·ª≠ l√Ω data race, m√¨nh s·∫Ω may m·∫Øn r√∫t ƒë∆∞·ª£c t·ªïng c·ªông 100k ·ªü c·∫£ 2 m√°y.

(tr√≠ch d·∫´n t·ª´ b√†i vi·∫øt t·∫°i Viblo)

Gi·∫£i ph√°p
Khi c√≥ nhi·ªÅu thread c√πng ƒë·ªçc v√† ghi v√†o shared resource, x√°c su·∫•t x·∫£y ra data race r·∫•t cao. N√™n vi·ªác gi·∫£i quy·∫øt v·∫•n ƒë·ªÅ n√†y c≈©ng kh√° l√† ƒë∆°n gi·∫£n.

Ta c·∫ßn ƒë·∫£m b·∫£o ch·ªâ duy nh·∫•t 1 thread ƒë∆∞·ª£c truy c·∫≠p v√†o shared resource t·∫°i m·ªôt th·ªùi ƒëi·ªÉm.
T·ª´ng thread s·∫Ω thay phi√™n nhau thao t√°c v·ªõi shared resource.
H√†nh ƒë·ªông c·ª© li√™n t·ª•c l·∫∑p l·∫°i cho ƒë·∫øn khi t·∫•t c·∫£ ƒë∆∞·ª£c tho·∫£ m√£n.
Trong l·∫≠p tr√¨nh, ƒëo·∫°n code d√πng ƒë·ªÉ read/write shared resource g·ªçi l√† critical section/critical region.

Vi·ªác thay phi√™n nhau s·ª≠ d·ª•ng critical section l√† c∆° ch·∫ø ƒë·ªÉ x·ª≠ l√Ω Data Race, g·ªçi l√† mutex. Hay c√≤n g·ªçi l√† mutual exclusion.

Chu·ªói h√†nh ƒë·ªông ƒë√≥ ƒë∆∞·ª£c g·ªçi l√† atomic operation v·ªõi c√°c ƒë·∫∑c t√≠nh:

Th·ª±c thi nh∆∞ m·ªôt thao t√°c duy nh·∫•t.
Qu√° tr√¨nh th·ª±c thi kh√¥ng b·ªã gi√°n ƒëo·∫°n b·ªüi b·∫•t k√¨ thread n√†o.
V√† b·∫°n c≈©ng ph·∫£i ch√∫ √Ω t·ªõi v·∫•n d·ªÅ Dead Lock khi kho√° m√£i m√£i.

Data Race vs. Race Condition
Ph·∫ßn l√Ω thuy·∫øt tr√™n ƒë√£ kh√° l√† m∆° h·ªì r·ªìi. Gi·ªù ch√∫ng ta l·∫°i ti·∫øp t·ª•c lo·∫°n n√£o ti·∫øp v·ªõi ph·∫ßn so s√°ch gi·ªØa ch√∫ng.

So s√°nh


Hai v·∫•n ƒë·ªÅ Data Race v√† Race Condition hay b·ªã ƒë√°nh ƒë·ªìng l√† m·ªôt (c√≥ l·∫Ω v√¨ c√πng t·ª´ race). Tuy nhi√™n n√≥ di·ªÖn t·∫£ hai v·∫•n ƒë·ªÅ kh√°c nhau trong l·∫≠p tr√¨nh multi-thread.

Race Condition

S·∫Ω t·∫≠p trung v√†o th·ª© t·ª± th·ª±c thi c·ªßa c√°c thread.
V·∫•n ƒë·ªÅ sai s√≥t v·ªÅ m·∫∑t th·ªùi gian ho·∫∑c th·ª© t·ª± th·ª±c thi c·ªßa c√°c thread trong ch∆∞∆°ng tr√¨nh khi·∫øn cho k·∫øt qu·∫£ cu·ªëi c√πng kh√¥ng ƒë√∫ng nh∆∞ mong mu·ªën.
Data Race

T·∫≠p trung v√†o m·∫∑t gi√° tr·ªã c·ªßa d·ªØ li·ªáu
C√°c gi√° tr·ªã b·ªã ghi ƒë√® l·∫´n nhau. D·∫´n t·ªõi vi·ªác ƒë·ªçc gi√° tr·ªã s·∫Ω b·ªã sai.
V·ªÅ c√°c gi·∫£i quy·∫øt 2 v·∫•n ƒë·ªÅ n√†y th√¨ kh√° gi·ªëng nhau. Ch·ªâ c·∫ßn ƒë·∫£m b·∫£o m·ªôt thread ƒë∆∞·ª£c truy c·∫≠p v√†o critical section t·∫°i m·ªôt th·ªùi ƒëi·ªÉm.

M·ªëi quan h·ªá
Trong th·ª±c t·∫ø, Race Condition x·∫£y ra do Data Race v√† Data Race d·∫´n ƒë·∫øn Race Condition. Kh√¥ng kh√°c nhau l·∫Øm nh·ªâ, tuy nhi√™n hai v·∫•n ƒë·ªÅ n√†y kh√¥ng ph·ª• thu·ªôc v√†o nhau.

M·ªôt ch∆∞∆°ng tr√¨nh c√≥ th·ªÉ c√≥ data race m√† kh√¥ng c√≥ race condition.
Ho·∫∑c c√≥ race condition m√† kh√¥ng c√≥ data race.
Ta h√£y xem m·ªôt v√≠ d·ª• nh∆∞ sau.

let concurrentQueue = DispatchQueue(label: "com.fx.queue1", attributes: .concurrent)
var number = 1
concurrentQueue.async {
    let temp = self.number
    self.number += 2
    print("#1: \(temp) + 2")
}
// Thread 2
concurrentQueue.async {
    let temp = self.number
    self.number *= 3
    print("#2: \(temp) * 3")
}
DispatchQueue.main.asyncAfter(deadline: .now() + 1.0) {
    print(self.number)
}
ƒê√¢y l√† v√≠ d·ª• cho vi·ªác th·ª±c hi·ªán m·ªôt bi·ªÉu th·ª©c ƒë∆°n gi·∫£n l√† 1 + 2 * 3. B·∫°n h√£y th·ª≠ ch·∫°y nhi·ªÅu l·∫ßn ƒëo·∫°n k·∫øt tr√™n, th√¨ s·∫Ω th·∫•y k·∫øt qu·∫£ r·∫•t b·∫•t ng·ªù.





B·∫°n c≈©ng d·ªÖ d√†ng nh·∫≠n th·∫•y k·∫øt qu·∫£ c·ªßa c√°c l·∫ßn ch·∫°y kh√°c nhau (9 & 5). ƒê√≥ c≈©ng l√† th·ª© t·ª± m√† b·∫°n th·ª±c hi·ªán bi·ªÉu th·ª©c 1 + 2 * 3.

N·∫øu nh√¢n chia tr∆∞·ªõc th√¨ s·∫Ω l√† 5
N·∫øu c·ªông tr·ª´ tr∆∞·ªõc th√¨ s·∫Ω l√† 9
ƒê√∫ng l√† Magic ph·∫£i kh√¥ng n√†o!

C√°c tr∆∞·ªùng h·ª£p kh√°c
Tuy t·ª•i n√≥ c√≥ m·ªëi quan h·ªá t∆∞∆°ng h·ªó l·∫ßn nhau. Tuy nhi√™n, c√≥ nhi·ªÅu tr∆∞·ªùng h·ª£p c√≥ c√°i n√†y kh√¥ng c√≥ c√°i kia. M√¨nh c√≥ th·ªÉ t√≥m t·∫Øt nh∆∞ sau:

C√≥ Data Race d·∫´n t·ªõi Race Condition.
(v√≠ d·ª• tr√™n nha)

C√≥ Race Condition m√† kh√¥ng c√≥ Data Race
Xem v√≠ d·ª• sau nha:

concurrentQueue.async {
    for i in 1...10 {
        print("üî¥ \(i)")
    }
}
concurrentQueue.async {
    for i in 1...10 {
        print("üîµ \(i)")
    }
}
ƒê∆°n gi·∫£n l√† ch√∫ng n√≥ m·∫°nh ai n·∫•y ch·∫°y. N·∫øu b·∫°n suy nghƒ© v·ªÅ th·ª© t·ª± l·∫ßn l∆∞·ª£t c·ªßa c√°c thread, th√¨ ƒë√¢y s·∫Ω r∆°i v√†o Race Condition v√† kh√¥ng c√≥ ·∫£nh h∆∞·ªüng n√†o t·ªõi d·ªØ li·ªáu h·∫øt.

C√≥ Data Race m√† kh√¥ng c√≥ Race Condition
B·∫°n xem qua v√≠ d·ª• n√†y nha.

var unsafeNumber: Int = 0
DispatchQueue.concurrentPerform(iterations: 100) { i in
    print("#\(i) : \(Thread.current)")
    unsafeNumber = i
}
print(unsafeNumber)
M·ªói l·∫ßn th·ª±c thi, b·∫°n s·∫Ω nh·∫≠n ƒë∆∞·ª£c m·ªôt k·∫øt qu·∫£ kh√°c nhau. Nguy√™n nh√¢n ch√≠nh l√† DispatchQueue.concurrentPerform, n√≥ th·ª±c thi ƒëo·∫°n code tr√™n nh·ªØng Thread kh√°c nhau. S·ªë l∆∞·ª£ng c√°c Thread tu·ª≥ thu·ªôc v√†o h·ªá th·ªëng quy·∫øt ƒë·ªãnh.

C√°c Thread n√†y c√πng nhau thay ƒë·ªïi gi√° tr·ªã c·ªßa number. H·∫ßu nh∆∞ m·ªçi th·ª© di·ªÖn ra t·ª©c th·ªùi v·ªõi nhau. Kh√¥ng c√≥ s·ª± xung ƒë·ªôt gi·ªØa c√°c Thread. Hay c√°i n√†y ·∫£nh h∆∞·ªüng c√°i kia. Do ƒë√≥, hi·ªán t∆∞·ª£ng Race Condition h·∫ßu nh∆∞ kh√¥ng x·∫£y ra.

Tuy nhi√™n, ƒë√≥ ch·ªâ l√† suy nghƒ© ch·ªß quan c·ªßa m√¨nh khi c·ªë t√¨m ra v√≠ d·ª• cho b·∫°n d·ªÖ hi·ªÉu. C√≤n n·∫øu d·ªÖ hi·ªÉu h∆°n l√† b√†i to√°n ATM ·ªü tr√™n. M√† m√¨nh c≈©ng kh√¥ng th·ªÉ c√†i ƒë·∫∑t hay th·ª±c thi 2 ch∆∞∆°ng tr√¨nh c√πng t∆∞∆°ng t√°c t·ªõi 1 database. N√™n ta t·∫°m xem n√≥ l√† l√Ω thuy·∫øt v·∫≠y.

Thread safety
T·ª´ v·∫•n ƒë·ªÅ Data Race tr√™n, c·ªông v·ªõi ng√¥n ng·ªØ m√† ch√∫ng ta ƒëang s·ª≠ d·ª•ng l√† Swift. V·ªõi Swift, h·∫ßu h·∫øt c√°c ki·ªÉu d·ªØ li·ªáu c·ªßa n√≥ m·∫∑c ƒë·ªãnh s·∫Ω kh√¥ng an to√†n cho thread.

C√°c Thread c√≥ th·ªÉ tho·∫£ m√°i truy c·∫≠p ƒë·ªçc/ghi gi√° tr·ªã l√™n c√°c bi·∫øn d√πng chung trong ch∆∞∆°ng tr√¨nh.

V√¨ v·∫≠y, ƒë·ªÉ tri·ªát ti√™u tri·ªát ƒë·ªÉ Data Race & Race Condition, th√¨ b·∫°n ph·∫£i c√≥ ƒë∆∞·ª£c Thread Safety ƒë·ªÉ s·ª≠ d·ª•ng th∆∞·ªùng xuy√™n. Ch√∫ng s·∫Ω ƒë·∫£m b·∫£o vi·ªác th·ª±c hi·ªán theo Serial Queue ho·∫∑c Lock Thread.

V√≠ d·ª•
B·∫°n xem qua v√≠ d·ª• code sau (l√† n√¢ng c·∫•p c·ªßa v√≠ d·ª• tr√™n). Nhi·ªám v·ª• c·ªßa n√≥ l√† l∆∞u l·∫°i t√™n c·ªßa c√°c Thread.

var threads: [Int: String] = [:]
DispatchQueue.concurrentPerform(iterations: 100) { i in
    threads[i] = "\(Thread.current)"
}
print(threads)
B·∫°n th·ª±c thi th√¨ s·∫Ω b·ªã crash ngay. ƒê√≥ ch√≠nh l√† h·ªá qu·∫£ c·ªßa Data Race g√¢y ra. Khi d·ªØ li·ªáu b·ªã s·ª≠a ƒë·ªïi li√™n t·ª•c v√† ƒë·ªìng th·ªùi, d·∫´n t·ªõi s·ª± tranh ch·∫•p nhau gi·ªØa nhi·ªÅu Thread. V√† ch∆∞∆°ng tr√¨nh s·∫Ω ng·ªßm c·ªß t·ªèi.

Gi·∫£i ph√°p
B·∫°n c√≥ th·ªÉ √°p d·ª•ng c√°c gi·∫£i ph√°p tr∆∞·ªõc ƒë√¢y c·ªßa Race Condition. Nh∆∞ng ·ªü ƒë√¢y ch√∫ng ta s·∫Ω c·ªë t·∫°o ra m·ªôt Thread Safety, nh·∫±m gi√∫p cho d·ªØ li·ªáu c·ªßa b·∫°n ƒë∆∞·ª£c an to√†n trong c√°c Thread.

V·∫´n l√† v√≠ d·ª• tr√™n, l·∫ßn n√†y b·∫°n s·∫Ω gi·∫£i quy·∫øt ch√∫ng b·∫±ng GCD nh∆∞ sau.

var threads: [Int: String] = [:]
let lockQueue = DispatchQueue(label: "my.serial.lock.queue")
DispatchQueue.concurrentPerform(iterations: 100) { i in
    lockQueue.sync {
        threads[i] = "\(Thread.current)"
    }
}
print(threads)
Ch√¨a kho√° ch√≠nh l√† Serial Queue (critical section). N√≥ ƒë·∫£m b·∫£o vi·ªác ghi d·ªØ li·ªáu l√† duy nh·∫•t. C√°c thread kh√°c nhau s·∫Ω l·∫ßn l∆∞·ª£t s·ª≠ d·ª•ng n√≥.

V√† t·∫•t nhi√™n, b·∫°n kh√¥ng th·ªÉ l√∫c n√†o c≈©ng khai b√°o th√™m 1 Serial Queue v√† ph·∫£i ghi nh·ªõ vi·ªác s·ª≠ d·ª•ng serialQueue.sync b·ªçc l·∫°i c√°c ƒëo·∫°n code nh∆∞ v·∫≠y. Ta s·∫Ω n√¢ng c·∫•p ch√∫ng th√†nh m·ªôt class x·ªãn s√≤ h∆°n.

Atomic Class
B·∫°n xem ti·∫øp v√≠ d·ª• cho custom class m·ªõi nha.

import Foundation
import Dispatch
class AtomicStorage {
    private let lockQueue = DispatchQueue(label: "my.serial.lock.queue")
    private var storage: [Int: String]
    
    init() {
        self.storage = [:]
    }
        
    func get(_ key: Int) -> String? {
        lockQueue.sync {
            storage[key]
        }
    }
    
    func set(_ key: Int, value: String) {
        lockQueue.sync {
            storage[key] = value
        }
    }
    var allValues: [Int: String] {
        lockQueue.sync {
            storage
        }
    }
}
Trong ƒë√≥:

C√°c thu·ªôc t√≠nh v√† ph∆∞∆°ng th·ª©c c·ªßa l·ªõp v·∫´n khai b√°o b√¨nh th∆∞·ªùng
Th√™m m·ªôt Serial Queue, v·ªõi vai tr√≤ l√† c∆° ch·∫ø kho√°
S·∫Ω tri·ªáu h·ªìi th√™m .sync cho c√°c thao t√°c ƒë·ªçc/ghi v·ªõi d·ªØ li·ªáu
C√°c d√πng nh∆∞ sau:

let storage = AtomicStorage()
DispatchQueue.concurrentPerform(iterations: 100) { i in
    storage.set(i, value: "\(Thread.current)")
}
print(storage.allValues)
Nh∆∞ v·∫≠y, b·∫°n s·∫Ω ƒë∆∞a Thread Safety v√†o trong m·ªôt custom class. Nh·∫±m ƒë·∫£m b·∫£o m·ª•c ƒë√≠ch ch√≠nh l√† an to√†n trong c√°c x·ª≠ l√Ω ƒëa lu·ªìng.

Ngo√†i ra, b·∫°n c√≥ th·ªÉ s·ª≠ d·ª•ng .barrier v·ªõi m·ªôt Concurrent Queue thay cho Serial Queue k√¨a. (tham kh·∫£o b√†i tr∆∞·ªõc nha)

Atomic Property
Theo tr√™n, b·∫°n c≈©ng ƒë√£ bi·∫øt v·ªõi Swift th√¨ m·∫∑c ƒë·ªãnh c√°c ki·ªÉu d·ªØ li·ªáu c·ªßa n√≥ l√† s·∫Ω kh√¥ng an to√†n cho vi·ªác t∆∞∆°ng t√°c trong c√°c Thread. V√† c√°ch gi·∫£i quy·∫øt l√† t·∫°o ra 1 Thread hay custom class v·ªõi m·ªôt Thread Safety.

Nh∆∞ng, n·∫øu ch√∫ng ta mu·ªën m·ªôt c√°ch d√πng n√†o ƒë√≥ nhanh g·ªçn l·∫π h∆°n, th√¨ th·∫≠t kh√≥. C√≤n v·ªõi ng√¥n ng·ªØ Objective-C, l·∫°i cho ph√©p ch√∫ng ta khai b√°o m·ªôt property/bi·∫øn v·ªõi t·ª´ kho√° l√† nonatomic & atomic. Khi v·ªõi atomic, bi·∫øn c·ªßa b·∫°n s·∫Ω ch·ªâ ƒë∆∞·ª£c m·ªôt Thread truy c·∫≠p v√† s·ª≠a ƒë·ªïi trong m·ªôt th·ªùi ƒëi·ªÉm nh·∫•t ƒë·ªãnh.

C√≤n Swift, ch√∫ng ta s·∫Ω c√≥ 1 gi·∫£i ph√°p kh√°c nh∆∞ sau:

Atomic Property = Thread Safety + Property Wrappers

 Khai b√°o
B·∫°n s·∫Ω s·ª≠ d·ª•ng t·ªõi Property Wrapper ƒë·ªÉ ƒë·ªãnh nghƒ©a m·ªôt struct cho ph√©p b·∫°n s·ª≠ d·ª•ng m·ªôt Thread Safety trong n√≥. Ta s·∫Ω √°p d·ª•ng DispatchQueue ƒë·ªÉ l√†m h·∫°t nh√¢n x·ª≠ l√Ω. B·∫°n tham kh·∫£o code c·ªßa n√≥ nha.

@propertyWrapper
struct Atomic<Value> {
    private let queue = DispatchQueue(label: "atomic")
    private var value: Value
    init(wrappedValue: Value) {
        self.value = wrappedValue
    }
    
    var wrappedValue: Value {
        get {
            return queue.sync { value }
        }
        set {
            queue.sync { value = newValue }
        }
    }
}
V·ªÅ Property Wrappers th√¨ m√¨nh s·∫Ω tr√¨nh b√†y t·∫°i m·ªôt b√†i vi·∫øt kh√°c.

 S·ª≠ d·ª•ng
V·ªõi vi·ªác ƒë·ªãnh nghƒ©a m·ªôt Property Wrappers, th√¨ s·ª≠ d·ª•ng n√≥ c≈©ng kh√° ƒë∆°n gi·∫£n. B·∫°n ch·ªâ c·∫ßn th√™m t·ª´ kho√° @Atomic (t√™n c·ªßa struct sau @) trong vi·ªác khai b√°o m·ªôt bi·∫øn hay m·ªôt thu·ªôc t√≠nh b·∫•t k√¨. B·∫°n c√≥ th·ªÉ s·ª≠ d·ª•ng n√≥ v√†o trong m·ªôt thu·ªôc t√≠nh c·ªßa m·ªôt class/struct n√†o ƒë√≥ c≈©ng ƒë∆∞·ª£c.

V√≠ d·ª•, ta khai b√°o l·∫°i bi·∫øn sau v·ªõi Property Wrappers tr√™n nha. Tham kh·∫£o code nha.

@Atomic var storage: [Int:String] = [:]
V√† ch√∫ng ta ti·∫øp t·ª•c s·ª≠ d·ª•ng l·∫°i v√≠ d·ª• tr√™n cho bi·∫øn m·ªõi ƒë√≥.

@Atomic var storage: [Int:String] = [:]
DispatchQueue.concurrentPerform(iterations: 100) { i in
    storage[i] = "\(Thread.current)"
}
print(storage)
V·ªõi c√°ch n√†y, b·∫°n kh√¥ng c·∫ßn thay ƒë·ªïi g√¨ nhi·ªÅu trong code. B·∫°n v·∫´n ƒë·∫£m b·∫£o ƒë∆∞·ª£c v·ªÅ m·∫∑t ho·∫°t ƒë·ªông c·ªßa ch∆∞∆°ng tr√¨nh v√† d·ªØ li·ªáu. B√™n c·∫°nh ƒë√≥ c√≤n tr√°nh ƒë∆∞·ª£c Data Race n·ªØa.
